<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Traffic Analysis System</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --bg: #f3f4f6;
            --card-bg: #ffffff;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --sidebar-width: 80px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            padding: 40px 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 50px; }
        h1 { font-size: 2.5rem; font-weight: 800; color: #111827; margin-bottom: 10px; }
        .subtitle { color: var(--text-muted); font-size: 1.1rem; }

        .section {
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            padding: 40px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .section h2 { font-size: 1.5rem; margin-bottom: 25px; font-weight: 700; }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .config-item { display: flex; flex-direction: column; gap: 8px; }
        .config-item label { font-weight: 600; font-size: 14px; color: var(--text-main); }
        .config-item input[type="number"] {
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
        }

        /* --- WORKSPACE --- */
        .workspace {
            display: flex;
            background: #1e293b;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
            border: 1px solid #334155;
            min-height: 650px;
        }

        .sidebar {
            width: var(--sidebar-width);
            background: #0f172a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 10px;
            border-right: 1px solid #334155;
        }

        .tool-group-label {
            color: #475569;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
            font-weight: 700;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            border: none;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn svg { width: 22px; height: 22px; fill: currentColor; }
        .tool-btn:hover { background: #334155; color: white; }
        
        .tool-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.4);
        }

        .sidebar-divider {
            width: 40px;
            height: 1px;
            background: #334155;
            margin: 5px 0;
        }

        .canvas-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            background: #000;
        }

        .workspace-header {
            background: #1e293b;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }

        .instruction-text { color: #cbd5e1; font-size: 14px; font-weight: 500; }
        .status-text { color: #94a3b8; font-size: 12px; }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            position: relative;
            background: #000;
        }

        canvas { display: block; cursor: crosshair; }

        .upload-zone {
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            padding: 80px 40px;
            text-align: center;
            background: #f9fafb;
            transition: all 0.2s ease;
            cursor: pointer;
            margin-bottom: 30px;
        }
        .upload-zone.dragover {
            border-color: var(--primary);
            background: #eef2ff;
            transform: scale(1.01);
        }

        .btn-group { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        button {
            background: var(--primary); color: white; border: none;
            padding: 16px 32px; border-radius: 10px; font-size: 16px; font-weight: 600;
            cursor: pointer; min-width: 180px;
        }
        button.btn-danger { background: var(--danger); }
        button.btn-danger:hover { background: var(--danger-hover); }

        .progress-container {
            width: 100%; background: #e5e7eb; border-radius: 999px;
            overflow: hidden; height: 40px; position: relative; margin: 20px 0;
        }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #4f46e5, #818cf8); width: 0%; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AI Traffic Analysis System</h1>
        </header>
        
        <!-- STEP 1: UPLOAD -->
        <div class="section" id="step-upload">
            <h2>1. Video Selection</h2>
            <div class="upload-zone" id="dropZone" onclick="document.getElementById('videoFile').click()">
                <div style="font-size: 40px; margin-bottom: 10px;">üì§</div>
                <div id="uploadText" style="font-weight: 700;">Click or Drag Video File Here</div>
            </div>
            <input type="file" id="videoFile" accept="video/*" style="display: none;" onchange="handleFileSelect()">
            <div class="btn-group"><button onclick="uploadVideo()">Upload & Initialize</button></div>
        </div>
        
        <!-- STEP 2: SETUP -->
        <div class="section hidden" id="step-setup">
            <h2>2. Design Detection Zones</h2>
            
            <div class="config-grid">
                <div class="config-item">
                    <label>Processing FPS</label>
                    <input type="number" id="fpsInput" value="30" min="1" max="120">
                </div>
                <div class="config-item" style="flex-direction: row; align-items: center; gap: 12px; margin-top: 20px;">
                    <input type="checkbox" id="showAreaToggle" checked style="width: 20px; height: 20px;">
                    <label>Show Detection Area in final video</label>
                </div>
            </div>

            <div class="workspace">
                <div class="sidebar">
                    <div class="tool-group-label">Zones</div>
                    <!-- Manual Polygon -->
                    <button class="tool-btn active" id="tool-polygon" onclick="setTool('polygon')" title="Manual Polygon">
                        <svg viewBox="0 0 24 24"><path d="M17,15.7L22,12.9V11L17,8.2L12,11V12.9L17,15.7M17,19L10,15.1V16.4L17,20.3L24,16.4V15.1L17,19M17,2L0,11.5V13.5L17,23L24,19V17L17,21L2,12.5L17,4.1L32,12.5V13.5L30,14.6V12.5L17,2Z" /></svg>
                    </button>
                    <!-- Rectangle -->
                    <button class="tool-btn" id="tool-rect" onclick="setTool('rect')" title="Add Rectangle">
                        <svg viewBox="0 0 24 24"><path d="M19,19H5V5H19M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" /></svg>
                    </button>
                    <!-- Circle -->
                    <button class="tool-btn" id="tool-circle" onclick="setTool('circle')" title="Add Circle">
                        <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>
                    </button>
                    <!-- Star -->
                    <button class="tool-btn" id="tool-star" onclick="setTool('star')" title="Add Star">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>

                    <div class="sidebar-divider"></div>
                    <div class="tool-group-label">Lines</div>

                    <!-- 2-Point Line -->
                    <button class="tool-btn" id="tool-line" onclick="setTool('line')" title="Simple 2-Point Line">
                        <svg viewBox="0 0 24 24"><path d="M15,3V7.59L7.59,15H3V21H9V16.41L16.41,9H21V3M17,5H19V7H17" /></svg>
                    </button>
                    <!-- Polyline -->
                    <button class="tool-btn" id="tool-polyline" onclick="setTool('polyline')" title="Multi-Point Line">
                        <svg viewBox="0 0 24 24"><path d="M22 6L19 12L14 8L9 16L2 12" fill="none" stroke="currentColor" stroke-width="2" /></svg>
                    </button>
                    <!-- Freehand/Wiggle -->
                    <button class="tool-btn" id="tool-freehand" onclick="setTool('freehand')" title="Freehand Wiggle Line">
                        <svg viewBox="0 0 24 24"><path d="M12,2C7,2 5,6 5,9C5,13 9,14 9,18C9,21 11.5,22 12,22C12.5,22 15,21 15,18C15,14 19,13 19,9C19,6 17,2 12,2Z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    
                    <div class="sidebar-divider"></div>
                    <!-- Delete -->
                    <button class="tool-btn" onclick="deleteSelected()" title="Delete Selected Object" style="color: var(--danger);">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>

                <div class="canvas-area">
                    <div class="workspace-header">
                        <div class="instruction-text" id="instruction">üìç Select a tool to begin</div>
                        <div class="status-text" id="selectionStatus">No object selected</div>
                    </div>
                    <div id="canvas-container"><canvas id="canvas"></canvas></div>
                </div>
            </div>
            
            <div class="btn-group">
                <button onclick="startProcessing()">Launch AI Analysis</button>
                <button class="btn-danger" style="background:transparent; color:var(--danger); border:1px solid var(--danger)" onclick="clearAll()">Reset All</button>
            </div>
        </div>
        
        <!-- STEP 3: PROCESSING -->
        <div class="section hidden" id="step-processing">
            <h2>3. AI Engine Processing</h2>
            <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            <p id="progressPercent" style="text-align:center;">0%</p>
            <p id="frameStats" style="text-align:center; color:gray;"></p>
            <div class="btn-group"><button class="btn-danger" onclick="cancelProcessing()">Cancel Analysis</button></div>
        </div>
        
        <!-- STEP 4: COMPLETE -->
        <div class="section hidden" id="step-complete">
            <h2 style="color: #059669;">‚úÖ Analysis Complete</h2>
            <div class="btn-group">
                <button onclick="downloadVideo()">Download Video</button>
                <button style="background:#10b981" onclick="downloadExcel()">Download Excel</button>
                <button style="background:#6b7280" onclick="location.reload()">New Analysis</button>
            </div>
        </div>
    </div>

    <script>
        let canvas, ctx, firstFrameImage;
        
        // --- DATA STRUCTURE FOR MULTIPLE OBJECTS ---
        // Each shape: { id: Date.now(), type: 'polygon'|'line', points: [{x,y},...] }
        let shapes = []; 
        let currentShape = null; // The shape currently being drawn
        let selectedShape = null; // The shape currently selected for editing/deleting
        
        let selectedTool = 'polygon';
        let isDrawing = false;
        let isDragging = false;
        let dragTarget = null; // { shapeIndex: int, pointIndex: int }
        
        const pointRadius = 6;

        // --- FILE HANDLING ---
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('videoFile');
        const uploadText = document.getElementById('uploadText');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, e => {e.preventDefault(); e.stopPropagation();}, false);
        });

        dropZone.addEventListener('dragover', () => dropZone.classList.add('dragover'));
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', e => {
            dropZone.classList.remove('dragover');
            fileInput.files = e.dataTransfer.files;
            handleFileSelect();
        });

        function handleFileSelect() {
            if(fileInput.files.length) uploadText.textContent = "Selected: " + fileInput.files[0].name;
        }
        
        function uploadVideo() {
            if (!fileInput.files.length) return alert('Select file first');
            const formData = new FormData();
            formData.append('video', fileInput.files[0]);
            uploadText.textContent = "Uploading...";
            fetch('/upload', {method: 'POST', body: formData})
                .then(res => res.json())
                .then(data => data.success ? loadFirstFrame() : alert(data.error));
        }

        function loadFirstFrame() {
            fetch('/first_frame').then(res => res.json()).then(data => {
                const img = new Image();
                img.onload = () => {
                    document.getElementById('step-upload').classList.add('hidden');
                    document.getElementById('step-setup').classList.remove('hidden');
                    canvas = document.getElementById('canvas');
                    ctx = canvas.getContext('2d');
                    const scale = Math.min(1, 1000 / img.width);
                    canvas.width = img.width * scale; canvas.height = img.height * scale;
                    firstFrameImage = img;
                    initCanvasEvents();
                    redraw();
                };
                img.src = data.image;
            });
        }

        // --- TOOLBAR ---
        function setTool(tool) {
            selectedTool = tool;
            // Finish any current shape immediately when switching tools
            if(currentShape) {
                currentShape = null;
                isDrawing = false;
            }

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const btn = document.getElementById('tool-' + tool);
            if(btn) btn.classList.add('active');
            
            const instruction = document.getElementById('instruction');
            if (['rect', 'circle', 'star'].includes(tool)) instruction.textContent = "üìç Click to place shape";
            else if (tool === 'freehand') instruction.textContent = "‚úèÔ∏è Drag to draw";
            else if (['polyline', 'polygon'].includes(tool)) instruction.textContent = "üìç Click to add points. Right-click to finish.";
            else instruction.textContent = "üìç Click to start drawing";
        }

        function deleteSelected() {
            if (!selectedShape) return alert("Select a shape first.");
            shapes = shapes.filter(s => s !== selectedShape);
            selectedShape = null;
            redraw();
            updateStatus();
        }
        
        function clearAll() {
            if(confirm("Delete all zones and lines?")) {
                shapes = []; selectedShape = null; currentShape = null; redraw();
            }
        }

        function updateStatus() {
            const el = document.getElementById('selectionStatus');
            if (!selectedShape) el.textContent = "No object selected";
            else el.textContent = `${selectedShape.type.toUpperCase()} Selected`;
        }

        // --- GEOMETRY GENERATORS ---
        function createRect(cx, cy, size=100) {
            return [
                {x: cx - size, y: cy - size}, {x: cx + size, y: cy - size},
                {x: cx + size, y: cy + size}, {x: cx - size, y: cy + size}
            ];
        }
        function createCircle(cx, cy, radius=80, steps=16) {
            let pts = [];
            for(let i=0; i<steps; i++) {
                let angle = (i / steps) * Math.PI * 2;
                pts.push({ x: cx + Math.cos(angle)*radius, y: cy + Math.sin(angle)*radius });
            }
            return pts;
        }
        function createStar(cx, cy, outer=80, inner=30, points=5) {
            let pts = [];
            let angle = Math.PI / points;
            for(let i=0; i<2*points; i++) {
                let r = (i % 2 === 0) ? outer : inner;
                let currA = i * angle - Math.PI/2;
                pts.push({ x: cx + Math.cos(currA)*r, y: cy + Math.sin(currA)*r });
            }
            return pts;
        }

        // --- CANVAS EVENTS ---
        function initCanvasEvents() {
            canvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', e => {
                e.preventDefault();
                // Right click finishes current shape
                if(currentShape) {
                    currentShape = null;
                    isDrawing = false;
                    redraw();
                }
            });
        }

        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            return { 
                x: (e.clientX - r.left) * (canvas.width / r.width), 
                y: (e.clientY - r.top) * (canvas.height / r.height) 
            };
        }

        function onMouseDown(e) {
            const pos = getPos(e);

            // 1. Check if clicking a Point (Edit Mode)
            const hit = checkPointHit(pos);
            if (hit) {
                isDragging = true;
                dragTarget = hit;
                selectedShape = shapes[hit.shapeIndex]; // Auto-select shape
                updateStatus();
                redraw();
                return;
            }

            // 2. Check if clicking a Shape Body (Selection Mode)
            const objHit = checkObjectHit(pos);
            if (objHit) {
                selectedShape = objHit;
                updateStatus();
                redraw();
                return; // Stop here, don't draw new shape if selecting
            }

            // 3. Drawing Logic
            // If we are just clicking empty space, deselect, unless we are in the middle of drawing
            if(!currentShape) selectedShape = null; 
            updateStatus();

            const isPoly = ['rect', 'circle', 'star', 'polygon'].includes(selectedTool);
            const type = isPoly ? 'polygon' : 'line';

            if (selectedTool === 'rect' || selectedTool === 'circle' || selectedTool === 'star') {
                let pts = [];
                if (selectedTool === 'rect') pts = createRect(pos.x, pos.y);
                else if (selectedTool === 'circle') pts = createCircle(pos.x, pos.y);
                else if (selectedTool === 'star') pts = createStar(pos.x, pos.y);
                
                const newShape = { id: Date.now(), type: 'polygon', points: pts };
                shapes.push(newShape);
                selectedShape = newShape; // Select newly created shape
                setTool('polygon'); // Reset to default tool

            } else if (selectedTool === 'freehand') {
                isDrawing = true;
                currentShape = { id: Date.now(), type: 'line', points: [pos] };
                shapes.push(currentShape);

            } else if (selectedTool === 'line') {
                // 2-point line logic: Create new, or replace if not finished? 
                // Let's make it create a new independent line every 2 clicks
                if(!currentShape) {
                    currentShape = { id: Date.now(), type: 'line', points: [pos] };
                    shapes.push(currentShape);
                } else {
                    currentShape.points.push(pos);
                    currentShape = null; // Finish after 2nd point
                }

            } else if (selectedTool === 'polyline' || selectedTool === 'polygon') {
                // Multi-point logic
                if(!currentShape) {
                    currentShape = { id: Date.now(), type: type, points: [pos] };
                    shapes.push(currentShape);
                } else {
                    currentShape.points.push(pos);
                }
            }

            redraw();
        }

        function onMouseMove(e) {
            const pos = getPos(e);

            if (isDragging && dragTarget) {
                shapes[dragTarget.shapeIndex].points[dragTarget.pointIndex] = pos;
                redraw();
                return;
            }

            if (isDrawing && selectedTool === 'freehand' && currentShape) {
                const last = currentShape.points[currentShape.points.length-1];
                if (Math.hypot(pos.x - last.x, pos.y - last.y) > 5) {
                    currentShape.points.push(pos);
                    redraw();
                }
                return;
            }

            // Cursor logic
            const ptHit = checkPointHit(pos);
            if (ptHit) canvas.style.cursor = 'move';
            else {
                 const objHit = checkObjectHit(pos);
                 canvas.style.cursor = objHit ? 'pointer' : 'crosshair';
            }
        }

        function onMouseUp() {
            isDragging = false;
            dragTarget = null;
            if (selectedTool === 'freehand') {
                isDrawing = false;
                currentShape = null; 
            }
        }

        // --- HIT TESTING ---
        function checkPointHit(pos) {
            for (let i = shapes.length - 1; i >= 0; i--) {
                const pts = shapes[i].points;
                for (let j = 0; j < pts.length; j++) {
                    if (Math.hypot(pts[j].x - pos.x, pts[j].y - pos.y) < pointRadius + 2) {
                        return { shapeIndex: i, pointIndex: j };
                    }
                }
            }
            return null;
        }

        function checkObjectHit(pos) {
            // Check top-most shape first
            for (let i = shapes.length - 1; i >= 0; i--) {
                const s = shapes[i];
                if (s.type === 'polygon') {
                    // Ray casting test for polygon inside
                    ctx.beginPath();
                    ctx.moveTo(s.points[0].x, s.points[0].y);
                    for(let k=1; k<s.points.length; k++) ctx.lineTo(s.points[k].x, s.points[k].y);
                    ctx.closePath();
                    if (ctx.isPointInPath(pos.x, pos.y)) return s;
                } else {
                    // Distance to segment for lines
                    for (let k=0; k<s.points.length-1; k++) {
                        if (distToSegment(pos, s.points[k], s.points[k+1]) < 8) return s;
                    }
                }
            }
            return null;
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function redraw() {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            if(firstFrameImage) ctx.drawImage(firstFrameImage, 0, 0, canvas.width, canvas.height);

            shapes.forEach(shape => {
                const isSel = (shape === selectedShape);
                const isPoly = shape.type === 'polygon';
                
                ctx.beginPath();
                if(shape.points.length > 0) ctx.moveTo(shape.points[0].x, shape.points[0].y);
                shape.points.forEach(p => ctx.lineTo(p.x, p.y));

                if(isPoly) {
                    ctx.closePath();
                    ctx.fillStyle = isSel ? 'rgba(79, 70, 229, 0.4)' : 'rgba(79, 70, 229, 0.2)';
                    ctx.fill();
                    ctx.strokeStyle = isSel ? '#ffffff' : '#4f46e5';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = isSel ? '#ffffff' : '#fbbf24';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    // If selected, draw a thin colored line inside the white selection to make it pop
                    if(isSel) {
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // Draw Vertices
                shape.points.forEach(p => {
                    ctx.beginPath(); 
                    ctx.arc(p.x, p.y, isSel ? 6 : 4, 0, 2*Math.PI);
                    ctx.fillStyle = isPoly ? '#4f46e5' : '#fbbf24'; 
                    ctx.fill();
                    ctx.strokeStyle = '#fff'; 
                    ctx.lineWidth=1; 
                    ctx.stroke();
                });
            });
        }

        let progressInterval;
        function startProcessing() {
            if (shapes.length === 0) return alert("Please add at least one zone or line.");
            
            const scale = firstFrameImage.width / canvas.width;
            
            // Separate shapes into lists for the backend
            const polygons = shapes.filter(s => s.type === 'polygon').map(s => s.points.map(p => [p.x*scale, p.y*scale]));
            const lines = shapes.filter(s => s.type === 'line').map(s => s.points.map(p => [p.x*scale, p.y*scale]));

            fetch('/set_regions', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    polygons: polygons, // Send Array of Arrays
                    lines: lines,       // Send Array of Arrays
                    processing_fps: parseInt(document.getElementById('fpsInput').value),
                    show_detection_area: document.getElementById('showAreaToggle').checked
                })
            }).then(() => {
                document.getElementById('step-setup').classList.add('hidden');
                document.getElementById('step-processing').classList.remove('hidden');
                fetch('/process', {method: 'POST'});
                progressInterval = setInterval(checkProgress, 1000);
            });
        }

        function checkProgress() {
            fetch('/progress').then(res => res.json()).then(data => {
                const prog = data.progress || 0;
                document.getElementById('progressBar').style.width = prog + '%';
                document.getElementById('progressPercent').textContent = prog + '%';
                document.getElementById('frameStats').textContent = `Frame ${data.current_frame || 0} / ${data.total_frames || 0}`;
                if (data.status === 'complete') {
                    clearInterval(progressInterval);
                    document.getElementById('step-processing').classList.add('hidden');
                    document.getElementById('step-complete').classList.remove('hidden');
                }
            });
        }

        function cancelProcessing() { 
            if (confirm("Stop analysis?")) {
                fetch('/cancel', {method: 'POST'}).then(() => location.reload()); 
            }
        }
        function downloadVideo() { window.location.href = '/download_video'; }
        function downloadExcel() { window.location.href = '/download_excel'; }
    </script>
</body>
</html>